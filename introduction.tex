\chapter{Introduction\label{chap:introduction}}

Linux is the most widely deployed open source general purpose
operating system. Traditionally, the aim of Linux scheduling is to
distribute cpu cycles fairly among tasks and task groups according to
their relative importance. Because of their popularity and high-level
of compatibility, Linux based systems are used to serve various kinds
of purposes. In some cases, fairness is not enough or necessary.

One important class of applications consists of hard real-time or soft
real-time systems. In order to work well, these applications have
requirements in terms of the CPU cycles they receive, or on the time
they need to react to external events. Such timing guarantee (or
\emph{real-time guarantee}) cannot be provided just by fairness.
Examples of soft real-time applications are multi-media applications.

%%
%% TODO: I do not understand the following sentence 
%%
Indeed, simply from CPU bandwidth management's point of view, a
real-time guarantee is also useful. 
%
In many situations, people prefer to distributing cpu power in a
privileged and predictable way. For instance, to give 10\% of the
total CPU cycles to a set of tasks; furthermore, take half of this
10\% and assign it to a subset of the tasks.

Nowadays, multi-core architectures are successfully used to boost
computing capability for computing devices. Common computing systems
with multiple processors are becoming mainstream: it is no surprise to
see an embedded device with more than one CPU inside.  Yet high speed
processors and more cores rather than solving the CPU timing guarantee
problem do bring more challenges. Also, no matter how powerful the
platform is, there is always time when people need more. So, to fully
utilize multi-core platform is also a good reason to manage computing
power in a real-time way.
%%
%% TODO: please use "real-time" instead of "real time" 
%%

In mainline Linux kernel, there are two so called real time scheduling 
policies: SCHED\_FIFO and SCHED\_RR. Tasks scheduled by them are called 
``real time(rt) tasks''. They are required in POSIX standard for 
POSIX-compliant operating systems like Linux. Unfortunately, despite of 
the name, these two policies can only provide real time gurantee in very 
limited conditions. In mainline Linux, there exist two non real time 
mechanisms to control CPU bandwidth distribution: real time (rt) throttling 
and complete fairness scheduler (CFS) bandwidth control. In principle, they 
are the same technique working for different types of tasks.

There is work that extends Linux with real time capabilities to fullfill 
the timing guarantee requirement: RTAI\cite{rtai}, AQuoSA\cite{Luigi09}, 
\texttt{sched-deadline} patch\cite{Dario09}, 
IRMOS real-time framework, RESCH and so on.
%%
%% TODO: Do not forget to insert citations where necessary, 
%% IRMOS, RESCH, RT-Xen.
%%
Instead of modifying the system directly, RT-Xen tries to apply real 
time mechanisms in the hypervisor level(Xen). 

Each work has its emphasis. Initially, our work is motivated by
IRMOS. 
%%
%% TODO You have not stated the objectives yet. This is the time to do it. 
%%
Our framework has two features:
\begin{itemize}
\item It can predictably distribute the cpu cycles of a
  multi-processor platform to a set of tasks and its subsets, without
  requirements for details how they are scheduled.
\item Under the framework, scheduling policies can be applied in a
  fine-grained way.
\end{itemize}


%%
%% TODO: I need to review this last part. 
%%
In Linux, there is a scheduling system on each CPU. Different such per
CPU scheduling systems construct the system level scheduling by task
migration mechanisms among different CPUs. For the first time in
Linux, our framework provides the opportunity to build extra
scheduling systems besides these destinated with each CPU. We call the
framework Open-Extension Container (OXC) scheduling
framework. Open-Extension (OX) container is a new data structure in
Linux that is introduced by our work.  It is the fundamental element
in the framework. Based on ox container structure, the concept ``per
oxc scheduling system'', whose behaviour is the same as ``per CPU
scheduling system'' in Linux, is given. Several per oxc scheduling
systems coorperate and work as the ``pseudo (Linux) system level
scheduling''.

In oxc scheduling framework, each ox-container can reserve an amount
of bandwidth from a CPU through CBS rules \cite{AbeniB98}. The per oxc
scheduling system based on it utilize this computing power to shcedule
tasks as if working on a less powerful cpu. This is how oxc framework
distribute reserved CPU cycles to tasks under it. Because the per oxc
scheduling has the same behaviour as per CPU scheduling in Linux,
general types of tasks can run using the reserved bandwidth. On
multiple processor platforms, different OXCs can inpdependently
reserve bandwidths from a subset of total CPUs and scheduling systems
above them work together to imitate the behaviour of the Linux system
level scheduling. The basic unit to apply a scheduling policy under
OXC framework is an OX container.
